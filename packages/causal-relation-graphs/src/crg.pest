lb = _{ "\n" | "\n\r" | "\r" }
ws = _{ ( " " | lb )* }
number = _{ '0'..'9' }
intLiteral = { ('1'..'9' ~ number*) | ("-" ~ '1'..'9' ~ number*) }

keywords = _{ "type" | "let" }

typeSymbol = { (('A'..'Z' | "_") ~ ('A'..'Z' | 'a'..'z' | '0'..'9' | "_")*) }
varSymbol = { !keywords ~ (('a'..'z' | "_") ~ ('A'..'Z' | 'a'..'z' | '0'..'9' | "_")*) }
likeString = { ('A'..'Z' | 'a'..'z' | '0'..'9' | "_" | "-" | " ")* }

idLiteral = { "Id" }
emptyLiteral = { "Empty" }
intContextTypeLiteral = { "Int" }
intExpr = _{ intLiteral | ("(" ~ ws? ~ intLiteral ~ ws? ~ ")") }
addEffectLiteral = { "+" ~ intExpr }
addEffectExpr = { addEffectLiteral }
stateLiteral = { "`" ~ likeString ~ "`" }
stateExpr = { idLiteral | emptyLiteral | stateLiteral }
transitionEffectLiteral = { stateExpr }
transitionEffectExpr = { "=>" ~ (idLiteral | emptyLiteral | transitionEffectLiteral) }
contextTypeLiteral = { varSymbol ~ ws? ~ ":" ~ ws? ~ effectTypeExpr }

applyLiteral = _{ contextTypeLiteral | idLiteral | emptyLiteral | varSymbol }

// TODO: scopeが書ける
stateMachineExpr = { typeLiteral | transitionEffectExpr }

effectTypeLiteral = { stateMachineExpr | intContextTypeLiteral | typeSymbol }
effectTypeExpr = { effectTypeLiteral }

snapshotTypeLiteral = { "{" ~ ws? ~ snapshotTypeItemLiterals* ~ ws? ~ "}" }
snapshotTypeItemLiterals = _{ snapshotTypeItemLiteral ~ (("," ~ (snapshotTypeItemLiteral))*)? }
snapshotTypeItemLiteral = { ws? ~ (snapshotTypeItemLiteralFull | snapshotTypeItemLiteralShort) ~ ws? }
snapshotTypeItemLiteralFull = _{ ws? ~ varSymbol ~ ws? ~ ":" ~ ws? ~ effectTypeExpr ~ ws? }
snapshotTypeItemLiteralShort = _{ ws? ~ varSymbol ~ ws? }


stateMachineTypeLiteral = { stateExpr ~ ws? ~ toState+ }
toState = _{ "=>" ~ ws? ~ stateExpr ~ ws? }

// comment

comment = { lb | ((!lb ~ ANY)* ~ (lb | EOI)) }
commentStart = _{ ws? ~ "//" }
commentLine = _{ commentStart ~ comment }

// typeの定義部分

stateMachineKeyword = { "StateMachine" }
contextKeyword = { "Context" }
snapshotKeyword = { "Snapshot" }
typeKeywords = { stateMachineKeyword | stateMachineKeyword | contextKeyword | snapshotKeyword }
bindTypeExpr = { ws? ~ typeSymbol ~ ws? ~ "::" ~ ws? ~ typeKeywords }
assignTypeExpr = { bindTypeExpr ~ ws? ~ "=" ~ ws? ~ typeExpr }

stateMachineTypeExpr = { stateMachineTypeLiteral }
contextedTypeExpr = { contextTypeLiteral }
snapshotTypeExpr = { snapshotTypeLiteral }
typeLiteral = { stateMachineTypeExpr | contextedTypeExpr | snapshotTypeExpr }

typeAndOp = { "&" }
typeOps = _{ typeAndOp }
typeOp = { ws? ~ typeOps ~ ws? }

typeExpr = { (typeFactor ~ ws? ~ tE) | typeTerm }
typeTerm = _{ ((typeLiteral | typeSymbol) | "(" ~ ws? ~ typeExpr ~ ws? ~ ")") }
typeFactor = _{ ws? ~ typeTerm ~ ws? }
tE = _{ typeOp ~ typeExpr }

typeStmt = { "type" ~ ws ~ (assignTypeExpr | bindTypeExpr) }

// expr

composeOp = { "compose" }
applyOp = { "apply" }
reduceOp = { "reduce" }
pushOp = { "<<" }
ops = _{ composeOp | applyOp | reduceOp | pushOp }
op = { ws ~ ops ~ ws }

snapshotLiteral = { "{" ~ ws? ~ snapshotItemLiterals* ~ ws? ~ "}" }
// TODO: scopeが書ける
// TODO: 任意の式が書ける
snapshotValueLiteral = { idLiteral | emptyLiteral | intExpr | stateExpr }
snapshotValueExpr = { snapshotValueLiteral }
snapshotItemLiteral = { ws? ~ contextExpr ~ ws? ~ ":" ~ ws? ~ snapshotValueExpr ~ ws? }
snapshotItemLiterals = _{ snapshotItemLiteral ~ (("," ~ (snapshotItemLiteral))*)? }

valueLiteral = _{ effectLiteral | applyLiteral | contextEffectLiteral | sliceLiteral | snapshotLiteral | scopeExpr }
sliceLiteral = { "[" ~ ws? ~ (contextEffectExpr ~ (ws? ~ "," ~ws? ~ contextEffectExpr)*)? ~ ws? ~ "]" }
// TODO: scopeが書ける
contextLiteral = { contextTypeLiteral }
// 値のContextExprは名前しか必要ないので、contextLiteralは不要かもしれない
contextExpr = { contextLiteral | varSymbol }
// TODO: scopeが書ける
effectLiteral = { idLiteral | emptyLiteral | addEffectExpr | transitionEffectExpr }
effectExpr = { varSymbol | effectLiteral }
// TODO: scopeが書ける
contextEffectLiteral = { "(" ~ ws? ~ contextExpr ~ ws? ~ "," ~ ws? ~ effectExpr ~ ws? ~ ")" }
contextEffectExpr = { contextEffectLiteral }

expr = { ws? ~ ((term ~ ws? ~ E) | term) ~ ws? }
// TODO: _つける
term = { valueLiteral | ("(" ~ ws? ~ expr ~ ws? ~ ")") }
E = _{ ws? ~ op ~ ws? ~ term ~ ws? }

calcStmt = { expr }

// let 関連

bindKeywords = { "Slice" | "Effect" | "ContextEffect" | "Context" | "Snapshot" }
// bindValuetypeExpr に型の式が書ける必要がある。{a: Int}みたいな
bindValueTypeExpr = { bindKeywords }

bindExpr = { ws? ~ varSymbol ~ ws? ~ "::" ~ ws? ~ bindValueTypeExpr ~ ws? }
assignExpr = { ws? ~ bindExpr ~ ws? ~ "=" ~ ws? ~ expr ~ ws?}
letStmt = { "let" ~ (assignExpr | bindExpr) }

// scope

stmtOrComment = _{ stmt | commentLine }
stmtTerminal = { ";" }
scopeInner = { ws? ~ ((stmtOrComment+ ~ (expr ~ commentLine*)) | (commentLine* ~ expr ~ commentLine*)) ~ ws? }
scopeLiteral = { ws? ~ "{" ~ ws? ~ scopeInner ~ ws? ~ "}" ~ ws? }
scopeExpr = { scopeLiteral }
scopeStmt = { scopeExpr }

// stmt

stmt = { ws? ~ (( scopeStmt | calcStmt | typeStmt | letStmt) ~ ws? ~ ";") }
rootScope = { ws? ~ scopeInner ~ ws? }

document = { SOI ~ rootScope ~ EOI }

// いずれ {} で式を書けるようにする
// Context型がUpperCamelCaseになってしまっている
// reduceではなく、SliceにSnapshotをapplyすればいいのでは？
