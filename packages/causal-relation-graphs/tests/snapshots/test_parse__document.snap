---
source: packages/causal-relation-graphs/tests/test_parse.rs
assertion_line: 9
expression: "causal_relation_graphs::parse(content.as_str()).unwrap()"

---
- "  {};\n"
- "  {//hoge\n"
- "  };\n"
- "  {\n"
- "  +1;\n"
- "  // aa\n"
- "  +1;\n"
- "  };\n"
- "  a << a ;\n"
- "  +1 compose +1; +1;\n"
- "  {+1;};\n"
- "  {+1;   +1; +1 compose +1;  };\n"
- "  // {};\n"
- "  {+1;};\n"
- "\n"
- "  // 代入の右辺にさらに代入を書ける？\n"
- "  type A :: StateMachine;\n"
- "  a<<  a;\n"
- "  Id;\n"
- "  Empty;\n"
- "  =>a;\n"
- "  Id compose =>a;\n"
- "  Id compose Id;\n"
- "  ((Id) compose Id);\n"
- "  type Foo :: StateMachine = (Id => `a`) & (Id => `b`) & Foo;\n"
- "  type Foo :: StateMachine = (Id => `a`) & (Id => `b`) & Foo;\n"
- "  type Foo :: StateMachine = (Id => `a`);\n"
- "  type Foo :: Snapshot = { foo: Int, a, a: Id => `a`, a: Foo };\n"
- "  type Foo :: StateMachine;\n"
- "  type Foo :: StateMachine = Id => `a` => `b`;\n"
- "  type Foo :: StateMachine = Id => `a` => `b`;\n"
- "  type Foo :: Context = a: Int;\n"
- "  type Foo :: Snapshot = {  };\n"
- "  type Foo :: Snapshot = {  };\n"
- "  a reduce {};\n"
- "  [] << (a, +1);\n"
- "  let s :: Snapshot = a reduce {};\n"
- "  {};\n"
- "  {a: 1};\n"
- "  {a:Int: 1};\n"
- "  //{(a:Int): 1};\n"
- "  {a: 1, a: 2};\n"
- "  let _a :: Snapshot;\n"
- "  let _a :: Snapshot = {a: 1, b: hoge, c: 2};\n"
- "  let a :: Context;\n"
- "  let a :: Context = a:Int;\n"
- "  let a :: ContextEffect = (a, +1);\n"
- "  let d :: Effect;\n"
- "  let d :: Effect = +1;\n"
- "  let a :: Slice;\n"
- "  let a :: Slice = [(a, +1)];\n"
- "  [(a, +1)];\n"
- "  [(a: Int, +1)];\n"
- "  [(a, +1), (b, =>`a`)];\n"
- "  +1;\n"
- "  [];\n"
- "  +1;\n"
- "  (+1);\n"
- "  +1 compose +1;\n"
- "  let a :: Slice;\n"
- "  let a :: Slice = +1;\n"
- "  let a :: Slice = [];\n"
- "  (foo: Int apply +1) compose +1;\n"
- "  (+1 compose +1) compose (+1 compose +1);\n"
- "  +1 compose (+1 compose (+1 compose +1));\n"
- "  a apply +1;\n"
- "  +1 compose +1 compose +1;\n"
- "  a apply (+10 compose +10);\n"
- "\n"
- "  =>`a` compose =>`b`;\n"
- "  Id compose Empty;\n"
- "  +1 compose +10;\n"
- "  +(-1) compose +1;\n"
- "  +1 compose =>`a`;\n"
- "\n"
- "  type A :: StateMachine = Id => `start` => `a`;\n"
- "  type A :: Snapshot = {};\n"
- "  type A :: Snapshot = {a};\n"
- "  type A :: StateMachine ;\n"
- "  type A :: StateMachine  = Id => `start` => `end`;\n"
- "  type Foo :: Context = label: Int;\n"
- "  type A :: Snapshot  = {foo: A, bar: B, baz: Int};\n"
- "  type A :: Snapshot = {foo: A, foo};\n"
- "  // Contextのリテラルを書ける\n"
- "  // (foo :: Int) apply +1\n"
- "\n"
- "  type A :: StateMachine;\n"
- "  type A :: StateMachine = Id => `start` => `end;\n"
- "  type Context_a :: Context = foo: Int;\n"
- "  type B :: Snapshot = {foo: A, bar: B, baz: Int};\n"
- "\n"
- "  type AAA  :: Snapshot = { context_a, context_b, context_c: Int };\n"
- "\n"
- "  // ここはあとで実装する\n"
- "  // type Constraint A :: PositiveInt;\n"
- "  // VirtualActionはあとで実装する\n"
- "\n"
- "  hoge apply +10;\n"
- "  =>`a` compose =>`b`;\n"
- "  Id compose =>`b`;\n"
- "  +10 compose +10;\n"
- "  +10 compose +(10);\n"
- "  +10 compose +(-10);\n"
- "  hoge apply (+10 compose +10);\n"
- "  // (hoge apply (+10 compose +10)) compose (hoge apply (+10 compose +10));\n"
- "\n"
- "  // let a :: Slice;\n"
- "  // let a :: Slice = [];\n"
- "  // let a :: Slice = [(hoge, +1)] << (hoge, +1);\n"
- "  // ## << はPush演算で、左から解釈される。Pushされると新しいSliceを生成する\n"
- "  // a << (hoge, +1);\n"
- "  // let aa = push a (hoge, +10);\n"
- "  // push a (hoge, +10);\n"
- "  // push aa, a (hoge, +10);\n"
- "  // push a (bar, =>`registrated`);\n"
- "\n"
- "  // let a :: Slice;\n"
- "  // let c :: Slice = [a, a compose b];\n"
- "\n"
- "  // let snap1 Snapshot :: A;\n"
- "  // let snap2 Snapshot :: A & B;\n"
- "\n"
- "  // c reduce (snap1);\n"
- "\n"
- "  // // Outputで副作用を扱う構文をやりたい\n"
- "  // // 戻り値はEmpty\n"
- "  // Output << c reduce snap2;\n"
- "  // Output << (c reduce snap2);\n"
- "\n"
- "  // 戻り値の表示\n"
- "  // Return << c;\n"
- "  // Return << c;\n"
- "\n"
- Id:
    effect:
      addEffect: 1

